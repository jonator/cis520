
CIS 520 - Programming Project #1

                   
---- GROUP ----

Jon Ator jator@ksu.edu
Miles McLenon milesmclenon@ksu.edu
Brandon Fisher bmfisher@ksu.edu

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for
>> the TA, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation,
>> course text, lecture notes, and course staff.


                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

A1:
    In timer.c:

    /* stores list of sleeping threads */
    static struct list sleep_queue;

    /* semaphore to protect access to sleep_queue */
    static struct semaphore sleep_queue_sema;

    -----
    In thread.h:

    struct thread
        ...
        int64_t wakeup_tick;                /* Tick value the thread should be woken up on */
        ...
        struct list_elem sleep_elem;        /* List element for sleep_list in timer.c*/
        ...
    };


---- ALGORITHMS ----

A2:
    In timer_sleep(), we sema_down(&sleep_queue_sema) to protect our 
    sleep_queue in case other processes are trying to sleep at the same time.  
    We then disable interrupts and use an auxillary function to insert the thread
    into sleep_queue in non-decreasing order based on the tick when the 
    thread should wake up.  Next sema_up(&sleep_queue_sema), and call
    thread_block() to put the current thread to sleep.

A3:
    In timer_interrupt(), we wake threads from a list that has been
    pre-sorted. This ensures that the maximum number of threads checked
    for the need to wakeup is only 1 greater than the number of threads
    ready to wake at current tick. i.e. if no threads are ready, only 1
    thread will be checked. Furthermore, if there are no sleeping threads
    only the sleep_queue will be checked.

---- SYNCHRONIZATION ----

A4:
    In timer_sleep() sleep_queue can only be modified by one thread at a time due 
    to the protection from sleep_queue_sema.  If multiple threads call timer_sleep()
    simultaneously, one will be blocked on the sema_down instruction until the 
    other has inserted itself into the sleep_queue.  Interrupts are also disabled
    for the insertion and the call to thread_block().  The wakeup_tick is calculated
    before the sleep_queue_sema is downed, so the ticks will be accurate during 
    simultaneous calls to timer_sleep().

A5:
    We use two synchronization strategies to prevent race conditions
    while calling timer_sleep(). First, we use semaphores to prevent
    other threads (possibly on other cores) from attempting to insert
    itself in the sleep_queue. Next, we disable interrupts to prevent
    timer_interrupt() from checking for threads to be awoken at the 
    instant we are inserting a new thread into sleep_list.


---- RATIONALE ----

A6:
    Originally, we used a global list of structs to keep track of 
    threads that were sleeping. The struct consisted of an 'int
    wakeup_tick' to store the sleep duration in ticks, and a
    pointer to a 'struct semaphore;' used as a lock to block the sleeping
    thread and later awaken it once the 'wakeup_tick' duration condition
    was met. This approach was found to have too much overhead in the case
    where many threads were requesting to sleep within a short duration
    of time. Individually allocating and initializing semaphores for each
    sleeping thread was likely the cause of inefficiency. The superior
    approach involved using a list of sleeping threads, and then only
    accessing that data structure using a semaphore.


             PRIORITY SCHEDULING
             ===================

---- DATA STRUCTURES ----

B1:
    In synch.h
    /* Lock. */
    struct lock
    {
        ...
        struct list_elem elem;      /* List_elem used by thread to keep list of all owned locks */
        int promoted_priority;      /* Stores highest donated priority from waiting thread */
    };

    -----
    In thread.h 

    struct thread
    {
        ...
        struct lock *waiting_on;            /* Reference to lock thread is waiting on */
        struct list owned_locks;            /* List of locks thread has acquired */
    }

>> B2: Explain the data structure used to track priority donation.

    We tightly coupled priority donation to the resource being 
    requested (a lock).  A thread is able to track all locks that 
    it owns via the owned_locks.  It also tracks the lock that it
    is currently waiting on (if any).  Thus a thread's priority can
    be donated to a lock which is then considered 'promoted'.  If
    the thread that owns the requested lock is also waiting on a 
    second lock, the priority is recursively donated to the next 
    lock via: lock->holder->waiting.
    
In synch.h

struct lock 
  {
    ...
    struct list_elem elem;      /* List_elem used by thread to keep list of all owned locks*/
    int promoted_priority;      /* Stores highest donated priority from waiting thread */
  };

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

B3:
    When a lock, semaphore, or condition varable is realeased we then 
    wake up the leftmost thread with the highest priority considering 
    priority donation. 
    

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

B4:
    In our implementation of lock_acquire(), we call a promote_lock()
    if the lock is currently in use by another thread (i.e. the semaphore
    value is at 0). If promotion is necessary, the lock's 'promoted_priority'
    
    
>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?



---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?


              ADVANCED SCHEDULER [EXTRA CREDIT]
              =================================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

