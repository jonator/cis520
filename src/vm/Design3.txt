		           +---------------------------+
       	           |         CIS 520           |
		           | PROJECT 3: Virtual Memory |
		           |     DESIGN DOCUMENT       |
		           +---------------------------+

---- GROUP ----

Jonathan Ator   jator@ksu.edu
Miles McLenon   milesmclenon@ksu.edu
Brandon Fisher  bmfisher@ksu.edu

			PAGE TABLE MANAGEMENT
			=====================

---- ALGORITHMS ----

A1:
	On a memory access the page is first looked up in the thread's 
	page table. If the page already has a frame in physical memory
	the page struct will contain a pointer to the frame and no 
	further action is necessary.  If there is no frame, the page_in()
	function calls do_page_in() which attempts to allocate a frame.

	In the try_frame_alloc_and_lock() function, the kernel looks through
	all frames in the frame table one at a time.  If at any point it
	successfully finds a frame that it can obtain the frame lock and 
	also has no page currently assigned, the frame is chosen and returned.

	The pointers are then matched up (frame->page and page->frame).  To
	finalize the connection between page and frame, page_in() calls 
	pagedir_set_page() which maps the user's page->addr to the kernels
	physical frame->base.

---- SYNCHRONIZATION ----

A2:
	The function frame_alloc_and_lock() asserts that a lock is held by the calling
	thread. The calling thread is expected to have called frame_lock()
	prior to calling the function, and frame_unlock() prior.

		       PAGING TO AND FROM DISK
		       =======================

---- ALGORITHMS ----

B1:
	First, if all frames are considered occupied by pages, we then find the
	next frame to evict baed on how recent its page has been
	accessed, using page_accessed_recently(). If it has been accessed it is
	set to accessed, and skipped in a 'second chance' algorithm. Finally, if the
	page hasn't been accessed, page_out() is called on the page, and its frame
	is returned with the old page evicted.

B2:
	If there is a page fault the stack will be expaneded based on three conditions.
	The address is below esp, winthin 4 bytes, and is below the stack limit. When all
	three contitions are true then the stack will be expanded.

	

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

C1:
	Nothing was changed on the struct from the starter code provided.
	The mapping struct is used to track important information about
	memory mapped files.

	/* Binds a mapping id to a region of memory and a file. */
	struct mapping
	{
		struct list_elem elem;      /* List element. */
		int handle;                 /* Mapping id. */
		struct file *file;          /* File. */
		uint8_t *base;              /* Start of memory mapping. */
		size_t page_cnt;            /* Number of pages mapped. */
	};

---- ALGORITHMS ----

C2:
	Memory mapping a file provides a direct relation between
	the bytes of a virtual page of memory and the actual file
	stored on disk.  This allows users to access the file using
	memory commands, rather than file commands.

	In a page fault context, swap pages are read in from swap
	disk sectors rather than from files on disk.  Similarly on 
	eviction the swap pages are written out using block_write()
	to go to swap disk rather than to file_write() for the other
	pages.  Memory mapped files are read/written to actual files
	and not to swap disk.

C3:
	The file mapping process attempts to map one page at a time for
	the length of the file.  Overlapping is discovered in the 
	page_allocate() function if the hash table that organizes the
	user process' pages already has an element for that address.
	In this case, the page and mapping are rolled back and aborted.

---- RATIONALE ----

C4:
	Most of the implementation uses shared code regarding the dallocation
	of pages, however the actual writing to memory is different.

	MMapped pages that are deallocated are run through page_out() which
	will the write directly to the file associated with that page using
	file_write_at().

	However, with swap_out, bytes are written directly to the swap
	partition via block_write().

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?
	
	Compared to the previous assignents in this course the overall difficulty 
	was less. This is only because of the shortened length. The difficulty of
	the indidvidual compenents was on par with other tasks in this course.
	
>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

	I gained more insight into user program related paging, as well as
	how page data is associated with physical memory via frames.
